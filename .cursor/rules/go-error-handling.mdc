---
description:
globs: *.go
alwaysApply: false
---
# Idiomatic Go Error Handling

- **Explicit Error Checking**: Always explicitly check for errors. Don't ignore errors or use blank identifiers unless absolutely necessary and documented.
  ```go
  // ✅ DO: Check errors and handle them.
  value, err := someFunction()
  if err != nil {
      return nil, fmt.Errorf("failed to get value: %w", err)
  }

  // ❌ DON'T: Ignore errors.
  value, _ := someFunction()
  ```

- **Error Wrapping with `fmt.Errorf("...: %w", err)`**: Use `%w` to wrap errors, preserving the original error for inspection with `errors.Is` and `errors.As`.
  ```go
  // ✅ DO: Wrap errors to provide context.
  if err != nil {
      return 0, fmt.Errorf("read failed: %w", err)
  }

  // ❌ DON'T: Discard original error information.
  if err != nil {
      return 0, errors.New("read failed")
  }
  ```

- **Returning Errors Directly**: When possible, return errors directly up the call stack instead of logging them and returning a generic error. Let the caller decide how to handle the error.
  ```go
  // ✅ DO: Return the error for the caller to handle.
  func fetchData() ([]byte, error) {
      data, err := networkCall()
      if err != nil {
          return nil, err // Return the actual error
      }
      return data, nil
  }

  // ❌ DON'T: Log the error and return a new generic error, hiding context.
  func fetchDataBad() ([]byte, error) {
      data, err := networkCall()
      if err != nil {
          log.Printf("Error fetching data: %v", err)
          return nil, errors.New("data fetch failed")
      }
      return data, nil
  }
  ```

- **Avoiding `panic` for Recoverable Errors**: Use `panic` only for truly unrecoverable conditions (e.g., programming bugs, unrecoverable initialization failures). For expected errors, return an `error`.
  ```go
  // ✅ DO: Return error for expected issues.
  func parseConfig(path string) (Config, error) {
      if path == "" {
          return Config{}, errors.New("config path cannot be empty")
      }
      // ...
      return Config{}, nil
  }

  // ❌ DON'T: Use panic for something that could be handled.
  func parseConfigBad(path string) Config {
      if path == "" {
          panic("config path cannot be empty")
      }
      // ...
      return Config{}
  }
  ```

- **Custom Error Types**: Define custom error types for specific error conditions, especially when additional information is needed or when callers need to distinguish between different types of errors.
  ```go
  // ✅ DO: Define custom error types when logic depends on it.
  type ErrNotFound struct {
      Resource string
      ID       string
  }

  func (e *ErrNotFound) Error() string {
      return fmt.Sprintf("%s with ID %s not found", e.Resource, e.ID)
  }

  func getItem(id string) error {
      if id == "non-existent" {
          return &ErrNotFound{Resource: "item", ID: id}
      }
      return nil
  }

  // In caller:
  // err := getItem("non-existent")
  // if errors.As(err, &notFoundErr) {
  //     fmt.Printf("Custom error: %s\n", notFoundErr.Error())
  // }
  ```

- **Nil Pointers for Zero Values**: When a function can return an error, and the non-error return value is a pointer type, return `nil` for the pointer on error, not an uninitialized struct. This prevents confusion about partial valid results.
  ```go
  // ✅ DO: Return nil for pointer types on error.
  func NewUser(name string) (*User, error) {
      if name == "" {
          return nil, errors.New("name cannot be empty")
      }
      return &User{Name: name}, nil
  }

  // ❌ DON'T: Return an uninitialized struct when the intent is no valid result.
  func NewUserBad(name string) (*User, error) {
      if name == "" {
          return &User{}, errors.New("name cannot be empty") // This can be confusing
      }
      return &User{Name: name}, nil
  }
  ```
