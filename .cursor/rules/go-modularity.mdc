---
description:
globs:
alwaysApply: false
---
# Go Modularity and Package Organization

- **Single Responsibility Principle for Packages**: Each package should have a single, clear purpose and encapsulate related functionality. Avoid creating overly broad or generic packages.
  ```go
  // ✅ DO: Well-defined package purpose (e.g., 'auth' for authentication logic)
  package auth

  // ❌ DON'T: Generic package name with mixed concerns.
  // package utils // if it contains unrelated functions
  ```

- **Clear Internal vs. External APIs**: Use directory structure and naming to distinguish between internal packages (intended only for use within the module) and external packages (part of the module's public API). Internal packages should be placed under an `internal/` directory.
  ```go
  // Project Structure:
  // mymodule/
  // ├── cmd/
  // ├── pkg/
  // │   └── publicapi/
  // └── internal/
  //     └── privateimpl/

  // ✅ DO: Organize public and internal packages clearly.
  // import "mymodule/pkg/publicapi"
  // import "mymodule/internal/privateimpl" // Only allowed within 'mymodule'
  ```

- **Avoid Cyclic Dependencies**: Packages should form a directed acyclic graph. A package `A` should not depend on `B` if `B` also depends on `A`. This makes code harder to understand, test, and refactor.
  ```go
  // ✅ DO: Maintain a clear, one-way dependency flow.
  // Package 'database' depends on 'config', 'config' does not depend on 'database'.

  // ❌ DON'T: Create circular dependencies between packages.
  // package A imports package B
  // package B imports package A
  ```

- **Small Files, Focused Functions**: Break down large packages into smaller, more manageable files. Each file should ideally focus on a single aspect of the package's responsibility. Functions should be small and do one thing well.
  ```go
  // ✅ DO: Break down logic into focused files.
  // user_repository.go (contains User database operations)
  // user_service.go (contains User business logic)

  // ❌ DON'T: Put all logic for a large package into a single, massive file.
  // user.go (contains all user-related functions and types)
  ```

- **Minimal Imports**: Keep the number of imports in each file and package to a minimum. Only import what is necessary. Excessive imports can indicate that a package has too many responsibilities or that dependencies are not well-managed.
  ```go
  // ✅ DO: Import only necessary packages.
  import (
      "fmt"
      "net/http"
  )

  // ❌ DON'T: Import unused packages or packages that are not directly needed.
  // import (
  //     "context"
  //     "fmt"
  //     "io/ioutil"
  //     "log"
  //     "net/http"
  //     "os"
  //     "path/filepath"
  // )
  ```

- **Interface-Driven Design**: Use interfaces to define contracts between packages, especially when injecting dependencies or designing for testability. This promotes loose coupling and allows for easy swapping of implementations.
  ```go
  // ✅ DO: Define interfaces for dependencies.
  type DataStore interface {
      GetUser(id string) (User, error)
      SaveUser(user User) error
  }

  type UserService struct {
      store DataStore
  }

  func NewUserService(store DataStore) *UserService {
      return &UserService{store: store}
  }

  // ❌ DON'T: Couple directly to concrete implementations, making testing hard.
  // type UserService struct {
  //     store *ConcreteDataStore
  // }
  ```
