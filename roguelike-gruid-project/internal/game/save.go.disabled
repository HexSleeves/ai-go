package game

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"codeberg.org/anaseto/gruid"
	"github.com/lecoqjacob/ai-go/roguelike-gruid-project/internal/ecs"
	"github.com/lecoqjacob/ai-go/roguelike-gruid-project/internal/ecs/components"
	"github.com/sirupsen/logrus"
)

// SaveData represents the complete game state for serialization
type SaveData struct {
	Version     string                 `json:"version"`
	Timestamp   time.Time              `json:"timestamp"`
	PlayerID    ecs.EntityID           `json:"player_id"`
	Depth       int                    `json:"depth"`
	Entities    []SavedEntity          `json:"entities"`
	Map         SavedMap               `json:"map"`
	TurnQueue   SavedTurnQueue         `json:"turn_queue"`
	Messages    []SavedMessage         `json:"messages"`
	GameStats   SavedGameStats         `json:"game_stats"`
}

// SavedEntity represents an entity and its components
type SavedEntity struct {
	ID         ecs.EntityID           `json:"id"`
	Components map[string]interface{} `json:"components"`
}

// SavedMap represents the map state
type SavedMap struct {
	Width    int       `json:"width"`
	Height   int       `json:"height"`
	Cells    [][]int   `json:"cells"`    // Grid data
	Explored []uint64  `json:"explored"` // Explored bitset
}

// SavedTurnQueue represents the turn queue state
type SavedTurnQueue struct {
	CurrentTime uint64                `json:"current_time"`
	Entries     []SavedTurnQueueEntry `json:"entries"`
}

// SavedTurnQueueEntry represents a turn queue entry
type SavedTurnQueueEntry struct {
	EntityID ecs.EntityID `json:"entity_id"`
	Time     uint64       `json:"time"`
}

// SavedMessage represents a log message
type SavedMessage struct {
	Text      string      `json:"text"`
	Color     uint32      `json:"color"` // Color as uint32
	Timestamp time.Time   `json:"timestamp"`
}

// SavedGameStats represents game statistics
type SavedGameStats struct {
	PlayTime      time.Duration `json:"play_time"`
	MonstersKilled int          `json:"monsters_killed"`
	ItemsCollected int          `json:"items_collected"`
	DamageDealt   int           `json:"damage_dealt"`
	DamageTaken   int           `json:"damage_taken"`
}

const (
	SaveVersion = "1.0.0"
	SaveDir     = "saves"
	SaveFile    = "game.save"
)

// SaveGame saves the current game state to disk
func (g *Game) SaveGame() error {
	// Create saves directory if it doesn't exist
	if err := os.MkdirAll(SaveDir, 0755); err != nil {
		return fmt.Errorf("failed to create save directory: %w", err)
	}

	saveData := SaveData{
		Version:   SaveVersion,
		Timestamp: time.Now(),
		PlayerID:  g.PlayerID,
		Depth:     g.Depth,
	}

	// Save entities and their components
	entities := g.ecs.GetAllEntities()
	for _, entityID := range entities {
		savedEntity := SavedEntity{
			ID:         entityID,
			Components: make(map[string]interface{}),
		}

		// Save each component type
		if pos, ok := g.ecs.GetPosition(entityID); ok {
			savedEntity.Components["position"] = pos
		}
		if renderable, ok := g.ecs.GetRenderable(entityID); ok {
			savedEntity.Components["renderable"] = renderable
		}
		if health, ok := g.ecs.GetHealth(entityID); ok {
			savedEntity.Components["health"] = health
		}
		if name, ok := g.ecs.GetName(entityID); ok {
			savedEntity.Components["name"] = name
		}
		if g.ecs.HasComponent(entityID, components.CPlayerTag) {
			savedEntity.Components["player_tag"] = true
		}
		if g.ecs.HasComponent(entityID, components.CAITag) {
			savedEntity.Components["ai_tag"] = true
		}
		if g.ecs.HasComponent(entityID, components.CBlocksMovement) {
			savedEntity.Components["blocks_movement"] = true
		}
		if g.ecs.HasComponent(entityID, components.CCorpseTag) {
			savedEntity.Components["corpse_tag"] = true
		}
		if turnActor, ok := g.ecs.GetTurnActor(entityID); ok {
			savedEntity.Components["turn_actor"] = turnActor
		}

		saveData.Entities = append(saveData.Entities, savedEntity)
	}

	// Save map state
	saveData.Map = SavedMap{
		Width:    g.dungeon.Width,
		Height:   g.dungeon.Height,
		Explored: g.dungeon.Explored,
	}

	// Convert grid to serializable format
	saveData.Map.Cells = make([][]int, g.dungeon.Height)
	for y := 0; y < g.dungeon.Height; y++ {
		saveData.Map.Cells[y] = make([]int, g.dungeon.Width)
		for x := 0; x < g.dungeon.Width; x++ {
			point := gruid.Point{X: x, Y: y}
			cell := g.dungeon.Grid.Get(point)
			saveData.Map.Cells[y][x] = int(cell)
		}
	}

	// Save turn queue state
	saveData.TurnQueue = SavedTurnQueue{
		CurrentTime: g.turnQueue.CurrentTime,
	}

	// Save messages
	messages := g.log.GetMessages()
	for _, msg := range messages {
		savedMsg := SavedMessage{
			Text:      msg.Text,
			Color:     uint32(msg.Color),
			Timestamp: msg.Timestamp,
		}
		saveData.Messages = append(saveData.Messages, savedMsg)
	}

	// Serialize to JSON
	data, err := json.MarshalIndent(saveData, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal save data: %w", err)
	}

	// Write to file
	savePath := filepath.Join(SaveDir, SaveFile)
	if err := os.WriteFile(savePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write save file: %w", err)
	}

	logrus.Infof("Game saved to %s", savePath)
	return nil
}

// LoadGame loads a saved game state from disk
func (g *Game) LoadGame() error {
	savePath := filepath.Join(SaveDir, SaveFile)
	
	// Check if save file exists
	if _, err := os.Stat(savePath); os.IsNotExist(err) {
		return fmt.Errorf("no save file found at %s", savePath)
	}

	// Read save file
	data, err := os.ReadFile(savePath)
	if err != nil {
		return fmt.Errorf("failed to read save file: %w", err)
	}

	// Parse JSON
	var saveData SaveData
	if err := json.Unmarshal(data, &saveData); err != nil {
		return fmt.Errorf("failed to unmarshal save data: %w", err)
	}

	// Version check
	if saveData.Version != SaveVersion {
		logrus.Warnf("Save file version %s differs from current version %s", 
			saveData.Version, SaveVersion)
	}

	// Clear current game state
	g.ecs = ecs.NewECS()
	g.spatialGrid.Clear()

	// Restore basic game state
	g.PlayerID = saveData.PlayerID
	g.Depth = saveData.Depth

	// Restore map
	g.dungeon = NewMap(saveData.Map.Width, saveData.Map.Height)
	g.dungeon.Explored = saveData.Map.Explored

	// Restore grid cells
	for y := 0; y < saveData.Map.Height; y++ {
		for x := 0; x < saveData.Map.Width; x++ {
			if y < len(saveData.Map.Cells) && x < len(saveData.Map.Cells[y]) {
				point := gruid.Point{X: x, Y: y}
				cell := saveData.Map.Cells[y][x]
				g.dungeon.Grid.Set(point, cell)
			}
		}
	}

	// Restore entities
	for _, savedEntity := range saveData.Entities {
		// Create entity with specific ID (need to implement this in ECS)
		entityID := g.ecs.AddEntityWithID(savedEntity.ID)

		// Restore components
		for compType, compData := range savedEntity.Components {
			switch compType {
			case "position":
				if pos, ok := compData.(map[string]interface{}); ok {
					point := gruid.Point{
						X: int(pos["X"].(float64)),
						Y: int(pos["Y"].(float64)),
					}
					g.ecs.AddComponent(entityID, components.CPosition, point)
					g.spatialGrid.Add(entityID, point)
				}
			case "health":
				if healthData, ok := compData.(map[string]interface{}); ok {
					health := components.Health{
						CurrentHP: int(healthData["CurrentHP"].(float64)),
						MaxHP:     int(healthData["MaxHP"].(float64)),
					}
					g.ecs.AddComponent(entityID, components.CHealth, health)
				}
			case "player_tag":
				g.ecs.AddComponent(entityID, components.CPlayerTag, components.PlayerTag{})
			case "ai_tag":
				g.ecs.AddComponent(entityID, components.CAITag, components.AITag{})
			case "blocks_movement":
				g.ecs.AddComponent(entityID, components.CBlocksMovement, components.BlocksMovement{})
			case "corpse_tag":
				g.ecs.AddComponent(entityID, components.CCorpseTag, components.CorpseTag{})
			// Add more component types as needed
			}
		}
	}

	// Restore turn queue
	g.turnQueue.CurrentTime = saveData.TurnQueue.CurrentTime

	// Restore messages
	g.log.Clear()
	for _, savedMsg := range saveData.Messages {
		// Add message with original timestamp
		g.log.AddMessageWithTime(gruid.Color(savedMsg.Color), savedMsg.Text, savedMsg.Timestamp)
	}

	logrus.Infof("Game loaded from %s", savePath)
	return nil
}

// HasSaveFile checks if a save file exists
func HasSaveFile() bool {
	savePath := filepath.Join(SaveDir, SaveFile)
	_, err := os.Stat(savePath)
	return err == nil
}

// DeleteSaveFile removes the save file
func DeleteSaveFile() error {
	savePath := filepath.Join(SaveDir, SaveFile)
	if err := os.Remove(savePath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to delete save file: %w", err)
	}
	return nil
}
